# Mybatis高级查询  

&emsp;&emsp;本章主要包含的内容为MyBatis的高级结果映射，主要处理数据库一对一、一对多的查询，另外就是在MyBatis中使用存储过程的方法，处理存储过程的入参和出参方法，最后还介绍了Java中的枚举方法和数据库表字段的处理方法。  

## 高级结果映射  
&emsp;&emsp;在关系型数据库中，经常要处理一对一，一对多的关系。  
&emsp;&emsp;在RABC权限系统中还存在着一个用户拥有多个角色、一个角色拥有多个权限这样复杂的嵌套关系。在面对这种关系的时候，我们可能要写多个方法分别查询这些数据，然后组合到一起。这种处理方式特别适合在大型系统上，由于分库分表，这种用法可以减少表之间的关联查询，方便系统进行扩展。但是在一般的企业级应用中，使用MyBatis的高级结果映射便可以轻松地处理这种一对一、一对多的关系。  

### 一对一映射  
&emsp;&emsp;假设在RBAC权限系统中，一个用户只能拥有一个角色，为了举例，先把用户和角色之间的关系限制为一对一的关系。一对一映射因为不需要考虑是否存在重复数据，因此使用起来很简单，而且可以直接使用MyBatis的自动映射。使用自动映射实现在查询用户信息的同时获取用户拥有的角色。   

#### 使用自动映射处理一对一关系  
&emsp;&emsp;一个用户拥有一个角色，因此先在SysUser类中增加SysRole字段并添加相应的getter和setter方法。  
&emsp;&emsp;使用自动映射就是通过别名让MyBatis自动将值匹配到对应的字段上，简单的别名映射如user_name对应userName。
除此之外MyBatis还支持复杂的属性映射，可以多层嵌套，例如将role.role_name映射到role.roleName上。MyBatis会先查找role属性，
如果存在role属性就创建role对象，然后在role对象中继续查找roleName,将role_name值绑定到role对象的roleName属性上。  
&emsp;&emsp;下面根据自动映射规则，在UserMapper.xml中增加如下方法。  
```java  
    <select id="selectUserAndRoleById" resultType="tk.mybatis.simple.model.SysUser">
        select
            u.id,
            u.user_name userName,
            u.user_password userPassword,
            u.user_email userEmail,
            u.user_info userInfo,
            u.head_img headImg,
            u.create_time createTime,
            r.id "role.id",
            r.role_name "role.roleName",
            r.enabled "role.enabled",
            r.create_by "role.createBy",
            r.create_time "role.createTime"
            from sys_user u
            inner join sys_user_role ur on u.id = ur.user_id
            inner join sys_role r on ur.role_id = r.id
            where u.id = #{id}
    </select>
```  
&emsp;&emsp;注意上述方法中sys_role查询列的别名都是“role.”前缀，通过这种方式将role的属性都映射到了SysUser的role属性上。  
&emsp;&emsp;再到UserMapper的接口中添加对应的方法。  
```java  
    /**
     * 根据用户id获取用户信息和用户的角色信息
     *
     * @param id
     * @return
    */
    SysUser selectUserAndRoleById(Long id);
```  
&emsp;&emsp;通过测试的SQL日志可以看到已经查询出的一条数据，MyBatis将这条数据映射到了两个类中。  
像这种通过一次查询结果映射到不同对象的方式，称之为关联的嵌套结果映射。  
&emsp;&emsp;关联的嵌套结果映射需要关联多个表将所有需要的值一次性查询出来。这种方式的好处是减少数据库查询次数，减轻数据库的压力，
缺点是要写很复杂的SQL，并且当嵌套结果更复杂时，不容易一次写正确，由于要在应用服务器上将结果映射到不同的类上，因此也会增加应用服务器的压力。
当一定会使用到嵌套结果，并且整个复杂的SQL执行速度很快时，建议使用关联的嵌套结果映射。  
    
#### 使用resultMap配置一对一映射  
&emsp;&emsp;除了使用MyBatis的自动映射来处理一对一嵌套外，还可以在XML映射文件中配置结果映射。
上面的复杂对象映射也可以使用相同效果的resultMap进行配置，使用resultMap实现和上一节的例子相同的效果。  
&emsp;&emsp;在UserMapper.xml中增加如下的resultMap配置。  
```java  
    <resultMap id="userRoleMap" type="tk.mybatis.simple.model.SysUser">
        <!-- 使用映射继承后，下面部分可注释-->
        <id property="id" column="id"/>
        <result property="userName" column="user_name"/>
        <result property="userPassword" column="user_password"/>
        <result property="userEmail" column="user_email"/>
        <result property="userInfo" column="user_info"/>
        <result property="headImg" column="head_img" jdbcType="BLOB"/>
        <result property="createTime" column="create_time" jdbcType="TIMESTAMP"/>

        <!--        role相关属性-->
        <result property="role.id" column="role_id"/>
        <result property="role.roleName" column="role_name"/>
        <result property="role.enabled" column="enabled"/>
        <result property="role.createBy" column="create_by"/>
        <result property="role.createTime" column="role_create_time" jdbcType="TIMESTAMP"/>

    </resultMap>
```  
&emsp;&emsp;这种配置和上一节相似的地方在于，role中的property配置部分使用"role."前缀。
在column部分，为了避免不同表中存在相同的列，所有可能重名的列都增加了“role_”前缀。使用这种方式配置的时候，
还需要在查询时设置不同的别名。针对该方法在USerMapper.xml中增加一个selectUserAndRoleById2方法，如下：  
```java  
   <select id="selectUserAndRoleById2" resultMap="userRoleMap">
        select
            u.id,
            u.user_name,
            u.user_password,
            u.user_email,
            u.user_info,
            u.head_img,
            u.create_time,
            r.id role_id,
            r.role_name,
            r.enabled enabled,
            r.create_by create_by,
            r.create_time role_create_time
        from sys_user u
                 inner join sys_user_role ur on u.id = ur.user_id
                 inner join sys_role r on ur.role_id = r.id
        where u.id = #{id}
    </select>
```  
&emsp;&emsp;注意这个方法使用resultMap配置映射，所以返回值不能用resultType来设置，
而是需要使用resultMap属性将其配置为上面的userRoleMap。注意SQL中只有sys_role部分列为了
防止重名而增加了列命名，并且别名和resultMap中配置的column一致。在UserMapper接口中增加了对应的
方法，代码如下：  
```java  
    /**
     * 根据用户id获取用户信息和用户的角色信息
     *
     * @param id
     * @return
    */
    SysUser selectUserAndRoleById2(Long id);
```  
&emsp;&emsp;用过上一种再看这一种写法就会发现，resultMap非常繁琐，
不仅没有方便使用反而增加了更多的工作量。MyBatis是支持resultMap映射
继承的，因此要先简化上面的resultMap配值。在这个映射文件中本就存在一个userMap
的映射配置，因此userRoleMap只需要继承userMap,然后添加role特有的配置即可，userRoleMap
修改后的代码如下。  
```java  
    <resultMap id="userRoleMap" extends="userMap"
                type="tk.mybatis.simple.model.SysUser">

        <!--        role相关属性-->
        <result property="role.id" column="role_id"/>
        <result property="role.roleName" column="role_name"/>
        <result property="role.enabled" column="enabled"/>
        <result property="role.createBy" column="create_by"/>
        <result property="role.createTime" column="role_create_time" jdbcType="TIMESTAMP"/>

    </resultMap>
```  
    
#### 使用resultMap的association标签配置一对一映射  
&emsp;&emsp;在resultMap中，association标签用于和一个复杂的类型进行关联，即用于一对一的关联配置。  
&emsp;&emsp;在上面配置的基础上，再做修改，改成association标签的配置方式，代码如下。  
```java  
    <resultMap id="userRoleMap" extends="userMap"
                type="tk.mybatis.simple.model.SysUser">   
        <association property="role" columnPrefix="role_" javaType="tk.mybatis.simple.model.SysRole">
            <result property="role.id" column="role_id"/>
            <result property="role.roleName" column="role_name"/>
            <result property="role.enabled" column="enabled"/>
            <result property="role.createBy" column="create_by"/>
            <result property="role.createTime" column="role_create_time" jdbcType="TIMESTAMP"/>
        </association>
    </resultMap>
```
association标签包含以下属性。  
+ property：对应实体类中的属性名，必须填。  
+ javaType:属性对应的java类型。  
+ resultMap: 可以直接使用现有的resultMap,而不需要在这里配置。  
+ columnPrefix：查询列的前缀，配置前缀后，在子标签配置result的column时可以省略前缀。  

&emsp;&emsp;因为上面配置了属性role，因此在association内部配置result的property属性时，
直接按照SysRole对象中的属性名配置即可。另外我们还配置了columnPrefix="role_",在写SQL的时候，
和sys_role表相关的查询列的别名都要有“role_”前缀，在内部result配置column时，
需要配置成去掉前缀的列名，MyBatis在映射结果时会自动使用前缀和column值的组合去SQL查询的结果中取值。
这种配置方式实际上是很方便的，但是目前此处的写法无法体现。  
&emsp;&emsp;对于前面提到的修改后的resultMap，因为配置了列的前缀，因此还需要修改SQL，
代码如下：  
```java  
    <select id="selectUserAndRoleById2" resultMap="userRoleMap">
        select
            u.id,
            u.user_name,
            u.user_password,
            u.user_email,
            u.user_info,
            u.head_img,
            u.create_time,
            r.id role_id,
            r.role_name role_role_name,
            r.enabled role_enabled,
            r.create_by role_create_by,
            r.create_time role_create_time
        from sys_user u
                 inner join sys_user_role ur on u.id = ur.user_id
                 inner join sys_role r on ur.role_id = r.id
        where u.id = #{id}
    </select>
```  
&emsp;&emsp;注意和sys_role相关列的别名，都已经改成了“role_”前缀，特别注意role_name增加前缀后为role_role_name。  
&emsp;&emsp;使用association配置时还可以使用resultMap属性配置成一个已经存在的resultMap映射，一般情况下。
也可以手写一个resultMap,先把sys_role相关的映射提取出来，并把它放到RoleMapper中，代码如下。  
```java  
    <resultMap id="roleMap" type="tk.mybatis.simple.model.SysRole">
        <id property="id" column="id"/>
        <result property="roleName" column="role_name"/>
        <result property="enabled" column="enabled"/>
        <result property="createBy" column="create_by"/>
        <result property="createTime" column="create_time" jdbcType="TIMESTAMP"/>
    </resultMap>
```  
&emsp;&emsp;直接使用RoleMapper中的roleMap的时候，userRoleMap配置如下：  
```java  
    <resultMap id="userRoleMap" extends="userMap"
               type="tk.mybatis.simple.model.SysUser">
        <association property="role" columnPrefix="role_"
                     resultMap="tk.mybatis.simple.mapper.RoleMapper.roleMap"/>
    </resultMap>
```  

&emsp;&emsp;在移动之后，一定要注意引用resultMap的完整名字。  
&emsp;&emsp;写到这种程度已经很简单了，和最开始的方式相比少了主表的一部分别名，但从表仍然需要别名，另外还多了resultMap配置。  
&emsp;&emsp;目前讲到的这3种情况都属于“关联的嵌套结果映射”，即通过一次SQL查询根据表或指定的属性映射到不同的对象中。
除了这种方式，还有一种“关联的嵌套查询”，也就意味着还有额外的份额，下面来看第4种情况。  
    
#### association标签的嵌套查询  
&emsp;&emsp;除了前面3种通过查询获取结果，还可以利用简单的SQL通过多次查询转换为我们需要的结果，
这种方式与根据业务逻辑手动执行多次SQL的方式很像，最后会将结果组合为一个对象。  
&emsp;&emsp;association标签的桥套查询常用的属性如下。  
+ select:另外一个映射查询的id，MyBatis会额外执行这个查询获取嵌套对象的结果。  
+ column:列名（别名），将主查询种列的结果作为嵌套查询的参数，配置方式如column={prop1=col1,prop2=col2},prop1和prop2将作为嵌套查询的参数。  
+ fetchType：数据加载方式，可选值为lazy和eager，分别作为延迟加载和积极加载，这个配置会覆盖全局的lazyLoadingEnabled配置。   
    
&emsp;&emsp;使用嵌套查询的方式配置一个和前面功能一样的 方法，首先在UserMapper.xml种创建如下的resultMap。  
```java  
    <resultMap id="userRoleMapSelect" extends="userMap"
               type="tk.mybatis.simple.model.SysUser">
        <association property="role"
                     column="{id=role_id}"
                     select="tk.mybatis.simple.mapper.RoleMapper.selectRoleById"/>
    </resultMap>
```  
&emsp;&emsp;然后创建一个使用userRoleMapSelect的查询方法，代码如下。  
```java  
    <select id="selectUserAndRoleByIdSelect" resultMap="userRoleMapSelect">
        select
            u.id,
            u.user_name,
            u.user_password,
            u.user_email,
            u.user_info,
            u.head_img,
            u.create_time,
            ur.role_id
        from sys_user u
        inner join sys_user_role ur on u.id = ur.user_id
        where u.id = #{id}
    </select>
```  

&emsp;&emsp;注意表关联中已经没有sys_role,因为我们不是通过一个SQL获取全部的信息，
角色信息要通过配置的selectRoleById方法进行查询，这个方法写在ROleMapper.xml中，代码如下。  
```java  
    <select id="selectRoleById" resultMap="roleMap">
        select * from sys_role where id = #{id}
    </select>  
```  
&emsp;&emsp;注意，可用的参数是通过上面的column="{id=role_id}"进行配置的，因此在嵌套的SQL中
智能使用#{id}参数，当需要多个参数时，可以配置多个，使用逗号隔开即可，例如column="{id=role_id,name=role_name}"。
&emsp;&emsp;这种配置方式符合开始时预期 的结果，到那时由于嵌套查询会多执行SQL，所以还要考虑更多情况。在这个例子中，
是否一定会用到SysRole呢？如果查询出来并没有使用，那不就白白浪费一次查询吗？如果查询的不是1跳数据，而是N条数据，那就会出现N+1问题，主SQL会查询一次，查询除N条结果，这N条结果要各自执行一次查询，那就需要进行N次查询。如何解决这个问题呢？  
&emsp;&emsp;association标签中的fetchType数据加载方式，可以帮我们实现延迟加载，解决N+1问题。需要把fetchType设置为lazy，这样设置后，只有当调用getRole()方法获取role的时候，MyBatis才会执行嵌套查询去获取数据。  
+ 注意？在MyBatis的全局配置中，有一个参数为aggressiveLazyLoading。这个参数的含义是，当该参数设置为true时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载，反之，每种属性都将按需加载。需要在mybatis-config.xml中添加如下代码：  
```java  
    <settings>
        <!--   这个参数的含义是，当该参数设置为true时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载，反之每种属性将按需加载-->
        <!--   默认值为false，与书中不同，UserMapperTest.testSelectUserAndRoleByIdSelect()方法有具体的测试-->
        <setting name="aggressiveLazyLoading" value="false"/>
    </settings>
```  

+ 特别提醒！  
&emsp;&emsp;许多对延迟加载原理不太熟悉的朋友会经常遇到一些莫名其妙的问题：有些时候延迟加载可以得到数据，有些时候延迟加载就会报错，为什么会出现这种情况呢？  
&emsp;&emsp;MyBatis延迟加载是通过动态代理实现的，当调用配置时为延迟加载的属性方法时，动态代理的操作会触发，这些额外的操作就是通过MyBatis的SqlSession去执行嵌套SQL的。由于在和某些框架集成时，SqlSession的生命周期交给框架来管理，因此对象超出SqlSession生命周期调用时，会由于链接关闭等问题而抛出异常。在和Spring集成时，要确保只能在Service层调用延迟加载的属性。当结果从Service层返回至Controller层时，如果获取延迟加载的属性值，会因为SqlSession已经关闭而抛出异常。  

&emsp;&emsp;虽然这个方法已经满足了我们的要求，但是有些时候还是需要在触发某方法时将所有的数据都加载进来，而我们已经将aggressivelazyLoading设置为false，这种情况又该怎么解决？  
&emsp;&emsp;MyBatis仍然提供了参数lazyLoadTriggerMethods帮助解决这个问题，这个参数的含义是，当调用配置中的方法时，加载全部的延迟加载数据。默认值为“equals,clone,hashCode,toString”。因此在使用默认值的情况下，只要调用其中一个方法就可以实现加载调用对象的全部数据。  


### 一对多映射  
&emsp;&emsp;上面实现一对一映射有4种方式。一对多映射只有两种配置方式，都是使用collection标签进行的，下面来看具体介绍。  

#### collection集合的嵌套结果映射  
&emsp;&emsp;和association类似，集合的嵌套结果映射就是通过一次SQL查询将所有的结果查询出来，然后通过配置的结果映射，将数据映射到不同的对象中去。在一对多的关系中，主表的一条数据会对应关联表中的多条数据，因此一般查询时会查询多个结果，按照一对多的数据结构存储数据的时候，最终的结果数会小于等于查询的总记录数。  
&emsp;&emsp;在RAC权限系统中，一个用户拥有多个角色（注意，使用association是设定的特例，限制一个用户只有一个角色），每个角色又是多个权限的集合，所以要渐进式地去实现一个SQL，查询出所有用户和用户角色，以及角色所包含地所有权限信息地两层嵌套结果。 
&emsp;&emsp;现在SysUser类中添加属性,用于存储用户对应地多个角色。   
```java  
    /**
     * 用户角色的集合
    */
    private List<SysRole> roleList;
```  
&emsp;&emsp;在UserMapper.xml中创建resultMap，代码如下。  
```java  

```




























